// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file HelloWorld.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "HelloWorld.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define dds_examples_PayloadT_max_cdr_typesize 12ULL;



#define dds_examples_HelloWorldT_max_cdr_typesize 2332ULL;

#define dds_examples_PayloadT_max_key_cdr_typesize 0ULL;



#define dds_examples_HelloWorldT_max_key_cdr_typesize 8ULL;





dds_examples::PayloadT::PayloadT()
{
    // unsigned long long m_id
    m_id = 0;
    // dds_examples::ColorT m_color
    m_color = dds_examples::RED;

}

dds_examples::PayloadT::~PayloadT()
{


}

dds_examples::PayloadT::PayloadT(
        const PayloadT& x)
{
    m_id = x.m_id;
    m_color = x.m_color;
}

dds_examples::PayloadT::PayloadT(
        PayloadT&& x) noexcept 
{
    m_id = x.m_id;
    m_color = x.m_color;
}

dds_examples::PayloadT& dds_examples::PayloadT::operator =(
        const PayloadT& x)
{

    m_id = x.m_id;
    m_color = x.m_color;

    return *this;
}

dds_examples::PayloadT& dds_examples::PayloadT::operator =(
        PayloadT&& x) noexcept
{

    m_id = x.m_id;
    m_color = x.m_color;

    return *this;
}

bool dds_examples::PayloadT::operator ==(
        const PayloadT& x) const
{

    return (m_id == x.m_id && m_color == x.m_color);
}

bool dds_examples::PayloadT::operator !=(
        const PayloadT& x) const
{
    return !(*this == x);
}

size_t dds_examples::PayloadT::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return dds_examples_PayloadT_max_cdr_typesize;
}

size_t dds_examples::PayloadT::getCdrSerializedSize(
        const dds_examples::PayloadT& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void dds_examples::PayloadT::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_id;scdr << (uint32_t)m_color;
}

void dds_examples::PayloadT::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_color = (dds_examples::ColorT)enum_value;
    }

}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void dds_examples::PayloadT::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t dds_examples::PayloadT::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& dds_examples::PayloadT::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member color
 * @param _color New value for member color
 */
void dds_examples::PayloadT::color(
        dds_examples::ColorT _color)
{
    m_color = _color;
}

/*!
 * @brief This function returns the value of member color
 * @return Value of member color
 */
dds_examples::ColorT dds_examples::PayloadT::color() const
{
    return m_color;
}

/*!
 * @brief This function returns a reference to member color
 * @return Reference to member color
 */
dds_examples::ColorT& dds_examples::PayloadT::color()
{
    return m_color;
}



size_t dds_examples::PayloadT::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return dds_examples_PayloadT_max_key_cdr_typesize;
}

bool dds_examples::PayloadT::isKeyDefined()
{
    return false;
}

void dds_examples::PayloadT::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



dds_examples::HelloWorldT::HelloWorldT()
{
    // unsigned long long m_id
    m_id = 0;
    // dds_examples::PayloadT m_header

    // unsigned long long m_index
    m_index = 0;
    // string m_message
    m_message = "";

    // dds_examples::ColorT m_color
    m_color = dds_examples::RED;
    // dds_examples::ColorSequenceT m_colors

    // dds_examples::ThreeValuesT m_values
    memset(&m_values, 0, (3) * 8);

    // dds_examples::PayloadSequenceT m_arrayOfStructs


}

dds_examples::HelloWorldT::~HelloWorldT()
{








}

dds_examples::HelloWorldT::HelloWorldT(
        const HelloWorldT& x)
{
    m_id = x.m_id;
    m_header = x.m_header;
    m_index = x.m_index;
    m_message = x.m_message;
    m_color = x.m_color;
    m_colors = x.m_colors;
    m_values = x.m_values;
    m_arrayOfStructs = x.m_arrayOfStructs;
}

dds_examples::HelloWorldT::HelloWorldT(
        HelloWorldT&& x) noexcept 
{
    m_id = x.m_id;
    m_header = std::move(x.m_header);
    m_index = x.m_index;
    m_message = std::move(x.m_message);
    m_color = x.m_color;
    m_colors = std::move(x.m_colors);
    m_values = std::move(x.m_values);
    m_arrayOfStructs = std::move(x.m_arrayOfStructs);
}

dds_examples::HelloWorldT& dds_examples::HelloWorldT::operator =(
        const HelloWorldT& x)
{

    m_id = x.m_id;
    m_header = x.m_header;
    m_index = x.m_index;
    m_message = x.m_message;
    m_color = x.m_color;
    m_colors = x.m_colors;
    m_values = x.m_values;
    m_arrayOfStructs = x.m_arrayOfStructs;

    return *this;
}

dds_examples::HelloWorldT& dds_examples::HelloWorldT::operator =(
        HelloWorldT&& x) noexcept
{

    m_id = x.m_id;
    m_header = std::move(x.m_header);
    m_index = x.m_index;
    m_message = std::move(x.m_message);
    m_color = x.m_color;
    m_colors = std::move(x.m_colors);
    m_values = std::move(x.m_values);
    m_arrayOfStructs = std::move(x.m_arrayOfStructs);

    return *this;
}

bool dds_examples::HelloWorldT::operator ==(
        const HelloWorldT& x) const
{

    return (m_id == x.m_id && m_header == x.m_header && m_index == x.m_index && m_message == x.m_message && m_color == x.m_color && m_colors == x.m_colors && m_values == x.m_values && m_arrayOfStructs == x.m_arrayOfStructs);
}

bool dds_examples::HelloWorldT::operator !=(
        const HelloWorldT& x) const
{
    return !(*this == x);
}

size_t dds_examples::HelloWorldT::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return dds_examples_HelloWorldT_max_cdr_typesize;
}

size_t dds_examples::HelloWorldT::getCdrSerializedSize(
        const dds_examples::HelloWorldT& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += dds_examples::PayloadT::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.colors().size() > 0)
    {
        current_alignment += (data.colors().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += ((3) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.arrayOfStructs().size(); ++a)
    {
        current_alignment += dds_examples::PayloadT::getCdrSerializedSize(data.arrayOfStructs().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void dds_examples::HelloWorldT::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_id;scdr << m_header;scdr << m_index;scdr << m_message.c_str();scdr << (uint32_t)m_color;scdr << static_cast<uint32_t>(m_colors.size());
    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_colors.data()), m_colors.size());

    scdr << m_values;
    scdr << m_arrayOfStructs;

}

void dds_examples::HelloWorldT::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_id;
    dcdr >> m_header;
    dcdr >> m_index;
    dcdr >> m_message;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_color = (dds_examples::ColorT)enum_value;
    }

    {
        uint32_t seq_length = 0;
        dcdr >> seq_length;
        m_colors.resize(seq_length);
        dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_colors.data()), seq_length);
    }

    dcdr >> m_values;

    dcdr >> m_arrayOfStructs;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void dds_examples::HelloWorldT::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t dds_examples::HelloWorldT::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& dds_examples::HelloWorldT::id()
{
    return m_id;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void dds_examples::HelloWorldT::header(
        const dds_examples::PayloadT& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void dds_examples::HelloWorldT::header(
        dds_examples::PayloadT&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const dds_examples::PayloadT& dds_examples::HelloWorldT::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
dds_examples::PayloadT& dds_examples::HelloWorldT::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member index
 * @param _index New value for member index
 */
void dds_examples::HelloWorldT::index(
        uint64_t _index)
{
    m_index = _index;
}

/*!
 * @brief This function returns the value of member index
 * @return Value of member index
 */
uint64_t dds_examples::HelloWorldT::index() const
{
    return m_index;
}

/*!
 * @brief This function returns a reference to member index
 * @return Reference to member index
 */
uint64_t& dds_examples::HelloWorldT::index()
{
    return m_index;
}

/*!
 * @brief This function copies the value in member message
 * @param _message New value to be copied in member message
 */
void dds_examples::HelloWorldT::message(
        const std::string& _message)
{
    m_message = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void dds_examples::HelloWorldT::message(
        std::string&& _message)
{
    m_message = std::move(_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::string& dds_examples::HelloWorldT::message() const
{
    return m_message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::string& dds_examples::HelloWorldT::message()
{
    return m_message;
}
/*!
 * @brief This function sets a value in member color
 * @param _color New value for member color
 */
void dds_examples::HelloWorldT::color(
        dds_examples::ColorT _color)
{
    m_color = _color;
}

/*!
 * @brief This function returns the value of member color
 * @return Value of member color
 */
dds_examples::ColorT dds_examples::HelloWorldT::color() const
{
    return m_color;
}

/*!
 * @brief This function returns a reference to member color
 * @return Reference to member color
 */
dds_examples::ColorT& dds_examples::HelloWorldT::color()
{
    return m_color;
}

/*!
 * @brief This function copies the value in member colors
 * @param _colors New value to be copied in member colors
 */
void dds_examples::HelloWorldT::colors(
        const dds_examples::ColorSequenceT& _colors)
{
    m_colors = _colors;
}

/*!
 * @brief This function moves the value in member colors
 * @param _colors New value to be moved in member colors
 */
void dds_examples::HelloWorldT::colors(
        dds_examples::ColorSequenceT&& _colors)
{
    m_colors = std::move(_colors);
}

/*!
 * @brief This function returns a constant reference to member colors
 * @return Constant reference to member colors
 */
const dds_examples::ColorSequenceT& dds_examples::HelloWorldT::colors() const
{
    return m_colors;
}

/*!
 * @brief This function returns a reference to member colors
 * @return Reference to member colors
 */
dds_examples::ColorSequenceT& dds_examples::HelloWorldT::colors()
{
    return m_colors;
}
/*!
 * @brief This function copies the value in member values
 * @param _values New value to be copied in member values
 */
void dds_examples::HelloWorldT::values(
        const dds_examples::ThreeValuesT& _values)
{
    m_values = _values;
}

/*!
 * @brief This function moves the value in member values
 * @param _values New value to be moved in member values
 */
void dds_examples::HelloWorldT::values(
        dds_examples::ThreeValuesT&& _values)
{
    m_values = std::move(_values);
}

/*!
 * @brief This function returns a constant reference to member values
 * @return Constant reference to member values
 */
const dds_examples::ThreeValuesT& dds_examples::HelloWorldT::values() const
{
    return m_values;
}

/*!
 * @brief This function returns a reference to member values
 * @return Reference to member values
 */
dds_examples::ThreeValuesT& dds_examples::HelloWorldT::values()
{
    return m_values;
}
/*!
 * @brief This function copies the value in member arrayOfStructs
 * @param _arrayOfStructs New value to be copied in member arrayOfStructs
 */
void dds_examples::HelloWorldT::arrayOfStructs(
        const dds_examples::PayloadSequenceT& _arrayOfStructs)
{
    m_arrayOfStructs = _arrayOfStructs;
}

/*!
 * @brief This function moves the value in member arrayOfStructs
 * @param _arrayOfStructs New value to be moved in member arrayOfStructs
 */
void dds_examples::HelloWorldT::arrayOfStructs(
        dds_examples::PayloadSequenceT&& _arrayOfStructs)
{
    m_arrayOfStructs = std::move(_arrayOfStructs);
}

/*!
 * @brief This function returns a constant reference to member arrayOfStructs
 * @return Constant reference to member arrayOfStructs
 */
const dds_examples::PayloadSequenceT& dds_examples::HelloWorldT::arrayOfStructs() const
{
    return m_arrayOfStructs;
}

/*!
 * @brief This function returns a reference to member arrayOfStructs
 * @return Reference to member arrayOfStructs
 */
dds_examples::PayloadSequenceT& dds_examples::HelloWorldT::arrayOfStructs()
{
    return m_arrayOfStructs;
}


size_t dds_examples::HelloWorldT::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return dds_examples_HelloWorldT_max_key_cdr_typesize;
}

bool dds_examples::HelloWorldT::isKeyDefined()
{
    return true;
}

void dds_examples::HelloWorldT::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
   scdr << m_id;   
 
 
 
 
 
 
  
}


